name: Analyze Build Results

on:
  workflow_dispatch:
    inputs:
      DEFCONFIG:
        description: 'Kernel defconfig'
        required: true
        default: 'k69v1_64_k419_defconfig'

env:
  ARCH: arm64
  SUBARCH: arm64

jobs:
  analyze:
    runs-on: ubuntu-22.04
    timeout-minutes: 30

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python2.7 python2.7-dev file tree
        sudo ln -sf /usr/bin/python2.7 /usr/bin/python2

    - name: Clone kernel source
      run: |
        git clone --depth=1 --branch=mt6768-4.19 \
          https://github.com/NullableIsBellable/Gale-Kernel-Source.git \
          kernel-source
        echo "KERNEL_DIR=$(pwd)/kernel-source" >> $GITHUB_ENV

    - name: Comprehensive build output analysis
      run: |
        cd $KERNEL_DIR
        echo "=== 完整的编译输出分析 ==="
        
        # 检查整个 out 目录结构
        echo "1. 完整的 out 目录结构:"
        find out/ -type f -name "*" 2>/dev/null | head -50
        
        echo ""
        echo "2. 按文件类型分类:"
        echo "   对象文件 (.o): $(find out/ -name "*.o" 2>/dev/null | wc -l)"
        echo "   内核模块 (.ko): $(find out/ -name "*.ko" 2>/dev/null | wc -l)"
        echo "   归档文件 (.a): $(find out/ -name "*.a" 2>/dev/null | wc -l)"
        echo "   镜像文件: $(find out/ -name "Image*" -o -name "*.img" -o -name "*.gz" 2>/dev/null | wc -l)"
        
        echo ""
        echo "3. 搜索所有可能的内核镜像位置:"
        # 检查标准位置
        for path in "arch/arm64/boot" "boot" "usr" "kernel" ""; do
          if [ -d "out/$path" ]; then
            echo "   检查 out/$path:"
            find out/$path -name "Image*" -o -name "vmlinuz*" -o -name "kernel*" -o -name "*.img" 2>/dev/null | head -10
          fi
        done
        
        echo ""
        echo "4. 检查所有生成的文件（按大小排序）:"
        find out/ -type f -exec ls -lh {} \; 2>/dev/null | sort -k5 -hr | head -20
        
        echo ""
        echo "5. 检查 vmlinux 和相关文件:"
        find out/ -name "vmlinux*" -o -name "System.map" -o -name ".config" 2>/dev/null
        
        echo ""
        echo "6. 检查设备树文件:"
        find out/ -name "*.dtb" -o -name "*.dtbo" -o -name "dtb.img" -o -name "dtbo.img" 2>/dev/null
        
        echo ""
        echo "7. 详细的 arch/arm64/boot 目录:"
        ls -la out/arch/arm64/boot/ 2>/dev/null || echo "   out/arch/arm64/boot/ 目录不存在"
        
        # 检查是否生成了任何可启动的内核
        echo ""
        echo "8. 检查是否生成了可启动内核:"
        if find out/ -name "vmlinux" 2>/dev/null | grep -q .; then
          echo "   ✅ 找到了 vmlinux (未压缩的内核)"
          vmlinux_file=$(find out/ -name "vmlinux" | head -1)
          echo "   文件: $vmlinux_file"
          file "$vmlinux_file" 2>/dev/null || echo "   无法分析文件类型"
        else
          echo "   ❌ 没有找到 vmlinux"
        fi

    - name: Fix linking issues and build final kernel
      run: |
        cd $KERNEL_DIR
        echo "=== 修复链接问题并生成最终内核 ==="
        
        # 检查当前的构建状态
        if [ -f "out/vmlinux" ]; then
          echo "vmlinux 存在，尝试生成压缩内核..."
          
          # 尝试手动生成 Image.gz
          if [ -f "out/arch/arm64/boot/Image" ]; then
            echo "找到未压缩的 Image，生成 Image.gz..."
            gzip -k out/arch/arm64/boot/Image
            ls -lh out/arch/arm64/boot/Image.gz || echo "无法生成 Image.gz"
          else
            echo "生成未压缩的 Image..."
            # 使用 objcopy 从 vmlinux 提取 Image
            aarch64-linux-gnu-objcopy -O binary -R .note -R .comment -S out/vmlinux out/arch/arm64/boot/Image 2>/dev/null && {
              echo "✅ 成功生成 Image"
              gzip -k out/arch/arm64/boot/Image
              echo "✅ 生成 Image.gz"
              ls -lh out/arch/arm64/boot/Image.gz
            } || echo "无法生成 Image"
          fi
        else
          echo "没有找到 vmlinux，无法生成内核镜像"
        fi
        
        # 尝试修复链接问题
        echo "尝试修复未定义符号..."
        
        # 方法1: 禁用有问题的模块
        if [ -f "out/.config" ]; then
          echo "禁用有问题的驱动模块..."
          # 禁用导致链接错误的驱动
          ./scripts/config --file out/.config -d ACCDET_MT6358
          ./scripts/config --file out/.config -d MTK_SENSORS_1_0
          ./scripts/config --file out/.config -d INPUT_FINGERPRINT
          make O=out ARCH=arm64 olddefconfig
        fi

    - name: Final build attempt
      run: |
        cd $KERNEL_DIR
        echo "=== 最终构建尝试 ==="
        
        # 尝试完成构建
        make O=out ARCH=arm64 -j1 \
          CC="aarch64-linux-gnu-gcc" \
          CROSS_COMPILE="aarch64-linux-gnu-" \
          2>&1 | tail -20 || echo "构建完成或有错误"
        
        # 最终检查
        echo "=== 最终文件检查 ==="
        find out/ -name "Image*" -o -name "vmlinux" -o -name "*.gz" -o -name "*.img" 2>/dev/null | while read f; do
          echo "找到: $f ($(du -h "$f" 2>/dev/null | cut -f1 || echo '未知大小'))"
        done

    - name: Upload all build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: complete-build-analysis-${{ github.run_number }}
        path: |
          ${{ env.KERNEL_DIR }}/out/
        retention-days: 15

    - name: Create build report
      run: |
        cd $KERNEL_DIR
        echo "=== 构建报告 ===" > build-report.txt
        echo "构建时间: $(date)" >> build-report.txt
        echo "Defconfig: ${{ github.event.inputs.DEFCONFIG }}" >> build-report.txt
        echo "" >> build-report.txt
        
        echo "生成的文件:" >> build-report.txt
        find out/ -type f -name "Image*" -o -name "vmlinux*" -o -name "*.img" -o -name "*.gz" 2>/dev/null >> build-report.txt
        
        echo "" >> build-report.txt
        echo "文件详情:" >> build-report.txt
        find out/ -type f \( -name "Image*" -o -name "vmlinux*" -o -name "*.img" -o -name "*.gz" \) -exec ls -lh {} \; 2>/dev/null >> build-report.txt
        
        cat build-report.txt

    - name: Upload build report
      uses: actions/upload-artifact@v4
      with:
        name: build-report-${{ github.run_number }}
        path: |
          ${{ env.KERNEL_DIR }}/build-report.txt
        retention-days: 15