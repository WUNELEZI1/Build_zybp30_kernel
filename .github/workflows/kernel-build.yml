name: Build MT6768 Kernel (Direct Approach)

on:
  workflow_dispatch:
    inputs:
      DEFCONFIG:
        description: 'Kernel defconfig'
        required: true
        default: 'k69v1_64_k419_defconfig'

env:
  ARCH: arm64
  SUBARCH: arm64

jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 120

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install alternative toolchains
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential bc bison flex libssl-dev libelf-dev \
          git wget unzip python2.7 python2.7-dev \
          gcc-aarch64-linux-gnu gcc-arm-linux-gnueabi \
          libncurses-dev dwarves curl file tree
          
        # 安装Clang作为备选工具链
        sudo apt-get install -y clang lld
        sudo ln -sf /usr/bin/python2.7 /usr/bin/python2

    - name: Clone kernel source
      run: |
        git clone --depth=1 --branch=mt6768-4.19 \
          https://github.com/NullableIsBellable/Gale-Kernel-Source.git \
          kernel-source
        echo "KERNEL_DIR=$(pwd)/kernel-source" >> $GITHUB_ENV

    - name: Direct compile.h creation
      run: |
        cd $KERNEL_DIR
        echo "=== 直接创建 compile.h ==="
        
        rm -rf out
        mkdir -p out/include/generated
        
        # 创建完整的 compile.h 文件
        cat > out/include/generated/compile.h << 'EOF'
        #define UTS_MACHINE "aarch64"
        #define UTS_VERSION "#1 SMP PREEMPT $(date +%Y%m%d)"
        #define LINUX_COMPILE_BY "github-actions"
        #define LINUX_COMPILE_HOST "github"
        #define LINUX_COMPILER "gcc version $(aarch64-linux-gnu-gcc -dumpversion)"
        #define LINUX_COMPILE_DOMAIN ""
        #define VERMAGIC_STRING "4.19.0-github"
        EOF
        
        echo "手动创建了 compile.h"

    - name: Try Clang compilation
      run: |
        cd $KERNEL_DIR
        echo "=== 尝试使用 Clang 编译 ==="
        
        # 使用 defconfig
        make O=out ARCH=arm64 defconfig
        
        # 设置使用 Clang
        ./scripts/config --file out/.config -d CC_IS_GCC
        ./scripts/config --file out/.config -e CC_IS_CLANG
        ./scripts/config --file out/.config -e LD_IS_LLD
        
        # 禁用问题配置
        for config in MTK_CM_MGR UCLAMP_TASK BLK_INLINE_ENCRYPTION; do
          ./scripts/config --file out/.config -d $config 2>/dev/null || true
        done
        
        make O=out ARCH=arm64 olddefconfig
        
        echo "使用 Clang 编译..."
        time make O=out ARCH=arm64 -j$(nproc) \
          CC=clang LD=ld.lld \
          CLANG_TRIPLE=aarch64-linux-gnu- \
          CROSS_COMPILE=aarch64-linux-gnu- \
          2>&1 | tee build_clang.log

    - name: Try GCC with minimal config
      if: failure()
      run: |
        cd $KERNEL_DIR
        echo "=== 使用 GCC 和最小配置 ==="
        
        rm -rf out
        mkdir -p out
        
        # 使用 tinyconfig
        make O=out ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- tinyconfig
        
        # 启用必要配置
        ./scripts/config --file out/.config -e ARM64
        ./scripts/config --file out/.config -e MMU
        ./scripts/config --file out/.config -e TTY
        ./scripts/config --file out/.config -e SERIAL_AMBA_PL010
        ./scripts/config --file out/.config -e SERIAL_AMBA_PL010_CONSOLE
        ./scripts/config --file out/.config -e PRINTK
        
        make O=out ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- olddefconfig
        
        echo "最小配置编译..."
        time make O=out ARCH=arm64 -j$(nproc) \
          CROSS_COMPILE=aarch64-linux-gnu- \
          2>&1 | tee build_minimal.log

    - name: Direct object compilation and linking
      if: failure()
      run: |
        cd $KERNEL_DIR
        echo "=== 直接编译和链接对象文件 ==="
        
        # 清理并重新配置
        rm -rf out
        mkdir -p out
        make O=out ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig
        
        # 编译核心目录
        echo "分步编译..."
        for dir in init kernel arch/arm64/kernel lib mm fs ipc security crypto block drivers/base; do
          if [ -d "$dir" ]; then
            echo "编译 $dir..."
            make O=out ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- $dir/ -j$(nproc) 2>&1 | tail -3 || echo "$dir 编译完成或有警告"
          fi
        done

    - name: Force manual vmlinux creation
      run: |
        cd $KERNEL_DIR
        echo "=== 强制手动创建 vmlinux ==="
        
        # 收集所有对象文件
        find out/ -name "*.o" -type f > objects.list
        
        object_count=$(wc -l < objects.list)
        echo "找到 $object_count 个对象文件"
        
        if [ $object_count -gt 1000 ]; then
          echo "尝试手动链接 vmlinux..."
          
          # 使用链接脚本
          if [ -f "out/arch/arm64/kernel/vmlinux.lds" ]; then
            echo "使用 vmlinux.lds 链接..."
            aarch64-linux-gnu-ld -EL -p --no-undefined -X --build-id -o out/vmlinux \
              -T out/arch/arm64/kernel/vmlinux.lds @objects.list 2>&1 | tail -20 || {
              echo "第一次链接失败，尝试简化链接..."
              
              # 尝试不使用链接脚本
              aarch64-linux-gnu-ld -EL -p --no-undefined -X --build-id -o out/vmlinux \
                @objects.list 2>&1 | tail -10 || echo "简化链接也失败"
            }
          else
            echo "没有找到 vmlinux.lds，尝试直接链接"
            aarch64-linux-gnu-ld -EL -p --no-undefined -X --build-id -o out/vmlinux \
              @objects.list 2>&1 | tail -10 || echo "直接链接失败"
          fi
        else
          echo "对象文件数量不足，无法链接"
        fi

    - name: Create kernel image from objects
      run: |
        cd $KERNEL_DIR
        echo "=== 从对象文件创建内核镜像 ==="
        
        if [ -f "out/vmlinux" ]; then
          echo "找到 vmlinux，生成 Image..."
          mkdir -p out/arch/arm64/boot
          
          aarch64-linux-gnu-objcopy -O binary -R .note -R .comment -S out/vmlinux out/arch/arm64/boot/Image 2>&1 | tail -5 && {
            echo "✅ 生成 Image 成功"
            gzip -k -f out/arch/arm64/boot/Image
            echo "✅ 生成 Image.gz 成功"
          } || echo "objcopy 失败"
        else
          echo "没有 vmlinux，尝试从对象文件直接生成 Image"
          
          # 尝试直接链接为二进制
          if [ -f "objects.list" ] && [ $(wc -l < objects.list) -gt 1000 ]; then
            echo "尝试直接链接为二进制镜像..."
            aarch64-linux-gnu-ld -EL -Ttext=0x40080000 --build-id -o out/arch/arm64/boot/Image -s @objects.list 2>&1 | tail -5 && {
              echo "✅ 直接生成 Image 成功"
              gzip -k -f out/arch/arm64/boot/Image
              echo "✅ 生成 Image.gz 成功"
            } || echo "直接链接失败"
          fi
        fi

    - name: Check and package results
      run: |
        cd $KERNEL_DIR
        echo "=== 检查和打包结果 ==="
        
        echo "生成的文件:"
        find out/ -type f \( -name "vmlinux*" -o -name "Image*" -o -name "*.gz" \) -exec ls -la {} \; 2>/dev/null || echo "没有找到内核文件"
        
        # 检查对象文件
        echo "对象文件统计:"
        find out/ -name "*.o" | wc -l

    - name: Upload all artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: kernel-direct-build-${{ github.run_number }}
        path: |
          ${{ env.KERNEL_DIR }}/out/
          ${{ env.KERNEL_DIR }}/build_*.log
          ${{ env.KERNEL_DIR }}/objects.list
        retention-days: 30

    - name: Final analysis
      run: |
        cd $KERNEL_DIR
        echo "=== 最终分析 ==="
        
        if [ -f "out/arch/arm64/boot/Image.gz" ]; then
          echo "🎉 成功生成内核镜像!"
          echo "文件: out/arch/arm64/boot/Image.gz"
          echo "大小: $(du -h out/arch/arm64/boot/Image.gz | cut -f1)"
        elif [ -f "out/vmlinux" ]; then
          echo "⚠️ 生成了 vmlinux 但没有压缩镜像"
          echo "运行: gzip -c out/vmlinux > Image.gz"
        else
          echo "❌ 编译失败"
          echo ""
          echo "根本问题分析:"
          echo "1. 内核源码可能存在严重的不兼容问题"
          echo "2. 工具链版本不匹配"
          echo "3. 需要手动修复内核构建系统"
          echo ""
          echo "建议的下一步:"
          echo "1. 尝试在本地Ubuntu 22.04环境编译"
          echo "2. 使用不同的内核源码分支"
          echo "3. 联系内核源码维护者报告问题"
          echo "4. 考虑使用预编译的内核"
        fi